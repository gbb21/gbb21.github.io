<h1 id="collision-risk-of-fast-rolling-hash">Collision Risk of Fast Rolling Hash</h1>
<h2 id="fast-rolling-hash">Fast Rolling Hash</h2>
<p>When implement <em>Rabin–Karp</em> rolling hashing algorithms, it is important to pick the right power base <span class="math inline"><em>p</em></span> and modulo <span class="math inline"><em>m</em></span> in the following formula:</p>
<p><span class="math display"><em>H</em><em>a</em><em>s</em><em>h</em>(<em>X</em>, <em>n</em>) = (<em>H</em><em>a</em><em>s</em><em>h</em>(<em>X</em>, <em>n</em> − 1) * <em>p</em> + <em>X</em><sub><em>n</em></sub>) <strong>m</strong><strong>o</strong><strong>d</strong> <em>m</em></span></p>
<p>On one side, we want the period length of the $ p^n mod m $ as close to <span class="math inline"><em>m</em></span> as possible, while on the other side we want it to be computational efficient.</p>
<p>Usually we pick <span class="math inline"><em>m</em></span> as a big prime while <span class="math inline"><em>p</em></span> be the primitive element of the finite field <span class="math inline"><em>G</em><em>F</em>(<em>m</em>)</span>. Despite it can maximize the period length, it usually require division computation.</p>
<p>Another popular choice (<em>fast rolling hash</em>) is to use <span class="math inline">2<sup><em>n</em></sup></span> as the modulo number while picking an odd prime as <span class="math inline"><em>p</em></span> that making sure <span class="math inline">2<sup><em>n</em></sup></span> and <span class="math inline"><em>p</em></span> is co-prime. Please note that this will limit the maximal period length to <span class="math inline">(2<sup><em>n</em></sup>)/4</span>, but the module computation can be replaced by integer truncation.</p>
<h2 id="hash-collision">Hash Collision</h2>
<p>In general, the hash collision rate should be low if we choose the <span class="math inline"><em>p</em></span> and <span class="math inline"><em>m</em></span> wisely, and the collision rate will be reduced if you create multiple hash functions with different <span class="math inline"><em>p</em></span>. However, I just discovered a magic sequence <span class="math inline"><em>X</em></span> that can cause “Hash collision” easily, if you chose the <em>fast rolling hash</em> implementation.</p>
<p>For that magic sequence, if you pick any <span class="math inline"><em>m</em> = 2<sup><em>n</em></sup></span> as the modulo number and any <span class="math inline"><em>p</em></span> that co-prime with the <span class="math inline"><em>m</em></span>, the collision WILL HAPPEN, no matter how many hash functions you use. Please check out <a href="hash1024.py">Collision Example</a> for details, and feel free to try it out yourself.</p>
